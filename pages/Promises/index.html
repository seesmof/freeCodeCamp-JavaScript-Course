<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/javascript.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../src/index.css" />
    <title>Promises</title>
  </head>
  <body class="bg-neutral-100 text-neutral-900">
    <a
      href="./index.html"
      class="fixed bottom-2 right-2 flex h-8 w-8 items-center justify-center rounded-full bg-neutral-800 text-center font-medium text-neutral-100 lg:bottom-4 lg:right-4 lg:h-10 lg:w-10"
      title="Home"
    >
      <span>?</span>
    </a>

    <div class="mx-auto min-h-screen w-full max-w-4xl">
      <div class="flex flex-col p-4 lg:p-6">
        <!-- BREADCRUMBS -->
        <div class="breakdcrumbs-section">
          <a href="../index.html" class="underline-offset-4 hover:underline"
            >Home</a
          >
          &gt;
          <a
            href="../index.html#asynchronous-programming"
            class="underline-offset-4 hover:underline"
            >Asynchronous Programming</a
          >
          &gt;
          <a href="./index.html" class="underline-offset-4 hover:underline"
            >Promises</a
          >
        </div>

        <section class="section-template">
          <h2 class="section-heading">Promises</h2>

          <div class="flex flex-col gap-2">
            <p>
              So, promises in JS are objects that promise to return some data in
              the future, when they get it. But for now, when they dont have it,
              they just promise you that it will be there, but nobody knows at
              what time.
            </p>
            <p>
              Promises are used in asynchronous programming to return a value in
              the future. We can declare them by
              <kbd>new Promise(function (resolve, reject) {})</kbd>.
              <em>new</em> means that we create a new object,
              <em>Promise</em> is a constructor for this object, which takes a
              function as a parameter. This is where our async function goes.
              And the async function should also take two function:
              <em>resolve</em> and <em>reject</em>. <em>resolve</em> is called
              when the promise is resolved, or the data is successfully
              retrieved, and <em>reject</em> is called when the promise is
              rejected, or something went wrong while getting the data.
            </p>
            <p>
              In the example below we use a promise to get the data from an
              async function. The function is just a <kbd>setTimeout</kbd>,
              nothing serious there yet, and it resolves with some object, or,
              rejects with an error. If it resolves, we can see a text in green,
              if not, we can see an error a bit below in red.
            </p>
            <p>
              <strong>Example:</strong>
            </p>
            <div
              class="font-medium text-green-600"
              id="gotDataSuccessfully"
            ></div>
            <div class="font-medium text-red-600" id="didntGetData"></div>

            <p>
              Also, a little useful thing to know about the <kbd>.then</kbd> and
              <kbd>.catch</kbd> blocks is in then, it takes two parameters, for
              example onSuccess and onFail, and first one is executed when we
              resolve the promise and the second one when we reject it. And so
              if we put both parameters in the then, it will sort of compare the
              result and if there is a rejection, but also a success, it will be
              executed, as well as the other nested thens. Well, thats as far as
              I understood. But, if we have a catch nested in our promise call,
              if there's an error or a rejection at any point, it just skipps
              everything and jumps straight into that catch and handles the
              error there. Which makes sense.
            </p>
          </div>

          <script>
            const gotDataSuccessfully = document.getElementById(
              "gotDataSuccessfully"
            );
            const didntGetData = document.getElementById("didntGetData");

            const getWeather = () => {
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  resolve({
                    city: "New York",
                    country: "US",
                    temperature: 20,
                    humidity: 80,
                    pressure: 1000,
                  });
                  reject("Something went wrong");
                }, 100);
              });
            };

            getWeather()
              .then((data) => {
                gotDataSuccessfully.textContent =
                  data.city + ", " + data.country;
                console.log(data);
              })
              .catch((error) => {
                didntGetData.textContent = error;
                console.log(error);
              });

            const getWeather2 = () => {
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  reject("404");
                }, 100);
              });
            };

            const getResolve = () => {
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  resolve("ðŸŽ‰");
                }, 100);
              });
            };

            const onError = (errorCode) => {
              console.log(`Error: ${errorCode}`);
            };

            const onSuccess = (data) => {
              console.log(data);
            };

            getWeather2().then(getResolve).then(onSuccess).catch(onError);
          </script>
        </section>
      </div>
    </div>

    <script></script>

    <div id="root"></div>
    <script type="module" src="/src/other.jsx"></script>
  </body>
</html>
